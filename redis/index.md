Redis
=====

- 模块开发
- 发布订阅

详见ppt,之前在给别人介绍redis的时候讲过,这个不做markdown的转换了

1.缓存是什么?
先看计算机存储体系
```
+-----+        +---------------+        +---------------+        +--------+        +------+
| CPU | <----> | Cache Level 1 | <----> | Cache Level 2 | <----> | Memory | <----> | Disk |
+-----+        +---------------+        +---------------+        +--------+        +------+
```
了解过硬件的一些常识后,
我们大概的了解到 cpu 中的register(寄存器) 的读写速度要比 memory(内存) 快100倍左右
显然如果没有中间的 Cache Level 1  和 Cache Level 2 ,那么Cpu就要经常等  内存读写完毕之后再进行接下来的指令
这个肯定是无法接受的,举个例子, 你现在的电脑计算一个数学公式假设需要10秒钟,  如果去掉你电脑中的 高速缓存 ,那么此时计算这个数学公式可能就需要60秒甚至更长时间


在上述的计算机存储体系中,缓存(Cache)是为了解决CPU速度和内存速度的速度差异问题
1. web中缓存的作用
   1> 提升程序运行速度
   2> 由于缓存的读写速度比下一级的快,所以如果用户的请求大多数都在缓存这一层就被拦截了的话,可以大大提升系统的并发量

2. web框架中缓存的一致性确定(所谓一致性,就是看cache 中的数据和db中的数据是否一致 )

先介绍有3种缓存更新查询策略 Cache Aside pattern  和 Read/Write Through Pattern 和 Write Behind Caching Pattern

Cache Aside pattern 
缓存主要有两种操作:   查询   &   更新
    缓存查询过程
    ```
    +--------+         +--------------+        +----------+
    | Client |  <----> | Cache(Redis) | <----> | DataBase |
    +--------+         +--------------+        +----------+
       |                                            |
       +---------- if Cache lose -------------------+ 
    ```
    1. 先查缓存,如果有,则返回
    2. 如果缓存没有,就从数据库查询,并且用户将数据更新到缓存中

    缓存更新过程   
    ★★★★  这个更新流程是固定的,前人的经验告诉我们这么做就是最合理的   ★★★★
    ★  一定要先更新数据库 然后再让缓存失效    

我来说说 为什么 ★缓存更新★ 要这么做! 

例子1:
首先假设我们更新的时候是   先删除缓存   再更新数据库
再假设我们同时有一个  查询和更新 的并发
那么会发生这样的一个过程
1.更新  先将缓存删除 
2.查询  发现缓存没有数据,从数据库查询出数据,然后写入缓存
3.更新  更新数据库

结论:这样子缓存中的数据就是 脏数据


例子2:
如果我们用的是前人总结的经验 ,更新的时候  先更新数据库  再删除缓存
再假设我们同时有一个  查询和更新 的并发
那么会发生这样的一个过程
1.查询  发现缓存没有数据,从数据库查询出数据
2.更新  先更新数据库,再删除缓存
3.查询  将之前查询出的数据再写入缓存

这时候缓存中的数据将是脏数据,那为什么我们还是要用这个方式呢,因为例子2的情况发生的概率比例子1要小的多,为什么小的多,因为前人说的.其实也能理解,查询的时候在将数据写入缓存的时候被打断了,写入缓存速度极快,被打断概率比写入数据库被打断概率小的多的多.

Read/Write Through Pattern

Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出), Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。
```
    +--------+         +--------------+        +----------+
    | Client |  <----> | Cache(Redis) | <----> | DataBase |
    +--------+         +--------------+        +----------+
       |                                            |
       +---------- if Cache lose -------------------+ 
```
    1. 先查缓存,如果有,则返回
    2. 如果缓存没有,就从数据库查询, 缓存服务自己去数据库或者别的地方更新成为最新的数据


 Write Through 套路和 Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）


Write Behind Caching Pattern

这个比较简单,更新和查询都只对缓存进行操作,然后缓存异步地批量更新到数据库.